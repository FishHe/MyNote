# Java Native Interface (JNI)

> 为了实现Java与C/C++的相互调用，Java使用了JNI技术来实现。下面是官方文档，可惜实用性不强。

> https://docs.oracle.com/javase/10/docs/specs/jni/index.html

> 这篇笔记是基于**IntelliJ Idea**和**VS2017**的。

**目录**

* [Java调用C++](#javausecpp)
  * [在Java中建立接口](#interfaceinjava)
  * [在C++中实现](#implincpp)
  * [在Java中调用](#useinjava)
* [C++调用Java](#cppusejava)
  * [建立Java方法](#buildjavaclass)
  * [在C++中调用](#UseJavaInCpp)
  * [在JVM中使用外部dll库](#UseDllInJVM)

<a name="javausecpp"></a>
## Java调用C++

在Java中，是可以加载C++生成的DLL的，但必须事先在Java中设置接口，并从C++实现该接口。

<a name="interfaceinjava"></a>
### 在Java中建立接口


假设Java中需要C++中的一个加法函数：

```cpp

int fun(int a,int b)
{
    return a+b;
}

```

为了调用这个函数，需要现在Java中设置一个接口：

```java

package TestJNI;

public class TestJNI {

    static {
        //System.loadLibrary("TestJNI")会从系统路径中搜索TestJNI.dll
        //TestJNI.dll中应该有fun方法的实现
        System.loadLibrary("TestJNI");
    }
    //该方法的实现位于c++编译的dll中
    public static native int fun(int a,int b);
}

```


现在，编译这个Java类，在高版本的javac.exe中，使用-h <导出目录>，可以导出c++需要的头文件。（在低版本的JDK中，有javah.exe工具来帮助生成头文件。）

在IntelliJ Idea中，在File->Settings->Build, Excution, Deployment->Compiler->Java Compiler中可以设置参数。
![](assets/1536565849_7734.png)

编译完成后，会生成含有native方法的头文件。不需要编辑这个头文件，我们只需要在cpp文件中，实现头文件中出现的方法。

```cpp

  /* DO NOT EDIT THIS FILE - it is machine generated */
  #include <jni.h>
  /* Header for class TestJNI_TestJNI */

  #ifndef _Included_TestJNI_TestJNI
  #define _Included_TestJNI_TestJNI
  #ifdef __cplusplus
  extern "C" {
  #endif
  /*
   * Class:     TestJNI_TestJNI
   * Method:    fun
   * Signature: (II)I
   */
  JNIEXPORT jint JNICALL Java_TestJNI_TestJNI_fun
    (JNIEnv *, jclass, jint, jint);

  #ifdef __cplusplus
  }
  #endif

```


<a name="implincpp"></a>
### 在C++中实现
首先创建一个**Win32 Dll**项目，生成的Dll就是Java要使用的。

在C++中要使用JNI，须引用其头文件，头文件包含在JDK的include文件夹中。要包含的目录有：

* \Java\jdk-10.0.2\include
* \Java\jdk-10.0.2\include\win32
* 以及-h参数指定的接口头文件生成位置

![](assets/1536567671_18367.png)

现在，创建一个实现TestJNI_TestJNI_Impl.cpp，并写入以下内容：

```cpp
#include <TestJNI_TestJNI.h>

/*
 * Class:     TestJNI_TestJNI
 * Method:    fun
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_TestJNI_TestJNI_fun
(JNIEnv *, jclass, jint a, jint b)
{
	return a + b;
}
```

生成这个项目，会得到一个dll，这个dll就是Java所需要的。

<a name="useinjava"></a>
### 在Java中调用

在任意的Java代码中，调用TestJNI类中的接口。

```java
package TestJNI;

public class JavaClient {
    public static void main(String args[])
    {
        int c = TestJNI.fun(1,2);
        System.out.print(c);
    }
}
```

将dll放在java的工作目录下，或在编译器中通过**-Djava.library.path**参数指定dll所在目录，例如在我的项目中这样设置：

> -Djava.library.path=./x64/Release/

![](assets/1536568240_17658.png)

如果dll没有找到，会出现以下错误：

> Exception in thread "main" java.lang.UnsatisfiedLinkError: no TestJNI in java.library.path<br>
> at java.base/java.lang.ClassLoader.loadLibrary(ClassLoader.java:2654)<br>
> at java.base/java.lang.Runtime.loadLibrary0(Runtime.java:876)<br>
> at java.base/java.lang.System.loadLibrary(System.java:1875)<br>
> at TestJNI.TestJNI.<clinit>(TestJNI.java:6)<br>
> at TestJNI.JavaClient.main(JavaClient.java:6)<br>


<a name="cppusejava"></a>
## C++调用Java

先附上所有代码，然后一点点说明

```cpp
#include <jni.h>
#include <iostream>

int main(int argc, char * args)
{
	JavaVM *jvm;       /* denotes a Java VM */
	JNIEnv *env;       /* pointer to native method interface */
	JavaVMInitArgs vm_args; /* JDK/JRE 9 VM initialization arguments */
	JavaVMOption* options = new JavaVMOption[1];

	char ostr[] = "-Djava.class.path=H:/ProgramDesign/_MyProject/TestJNI/out/production/TestJNI";

	options[0].optionString = ostr;
	vm_args.version = JNI_VERSION_10;
	vm_args.nOptions = 1;
	vm_args.options = options;
	vm_args.ignoreUnrecognized = false;
	/* load and initialize a Java VM, return a JNI interface
	 * pointer in env */
	int res = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);
	delete options;
	/* invoke the Main.test method using the JNI */
	jclass cls = env->FindClass("TestJNI/JavaServer");
	jmethodID mid = env->GetStaticMethodID(cls, "fun", "(II)I");
	res = env->CallStaticIntMethod(cls, mid, 100, 100);

	std::cout <<"The result is : "<< res<<std::endl;

	/* We are done. */
	jvm->DestroyJavaVM();

	return 0;
}
```

在C++中运行JVM（Java虚拟机），并反射其中的类，来调用成员方法。

<a name="buildjavaclass"></a>
### 建立一个要调用的Java类

代码如下：

```java
package TestJNI;

public class JavaServer {

    public static int fun(int a,int b)
    {
        return a + b;
    }
}
```

生成class文件，也可继续打包生成jar。

<a name="UseJavaInCpp"></a>
### 在C++中创建JavaVM

JavaVM是C++中创建的Java运行环境，具体请参考官方文档：

> https://docs.oracle.com/javase/10/docs/specs/jni/invocation.html

下面是创建JavaVM的代码：

```cpp
JavaVM *jvm;       /* denotes a Java VM */
JNIEnv *env;       /* pointer to native method interface */
JavaVMInitArgs vm_args; /* JDK/JRE 9 VM initialization arguments */
JavaVMOption* options = new JavaVMOption[1];

//该参数指定了classpath
char ostr[] = "-Djava.class.path=H:/ProgramDesign/_MyProject/TestJNI/out/production/TestJNI";

options[0].optionString = ostr;
vm_args.version = JNI_VERSION_10;
vm_args.nOptions = 1;
vm_args.options = options;
vm_args.ignoreUnrecognized = false;
/* load and initialize a Java VM, return a JNI interface
 * pointer in env */
int res = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);

/*
//错误
if(res!=0) return -1;
*/

```

反射类，参数的构成方式是：<包/类名>
```cpp
jclass cls = env->FindClass("TestJNI/JavaServer");
```

反射类中的方法，需要给出正确的签名，签名可通过javap工具来获取：

> javap.exe -s -p <类文件>

JavaServer类各成员的签名为**descriptor：**
后的内容

>Compiled from "JavaServer.java"</br>
public class TestJNI.JavaServer {</br>
  public TestJNI.JavaServer();</br>
    descriptor: ()V</br>
</br>
  public static int fun(int, int);</br>
    descriptor: (II)I</br>
}</br>

现在，在C++中，反射方法，并调用：

```cpp
jmethodID mid = env->GetStaticMethodID(cls, "fun", "(II)I");
res = env->CallStaticIntMethod(cls, mid, 100, 100);
```

最后，记得关闭虚拟机：
```cpp
/* We are done. */
jvm->DestroyJavaVM();
```

<a name="UseDllInJVM"></a>
### 在JVM中使用外部Dll库
JavaVM并不会在反射类时，自动调用类的Dll外部库，需要用户手动载入，需要手动强制载入dll库。

```cpp
System.loadLibrary("*.dll");
```
